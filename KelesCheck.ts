

export module TypeClasses {
    // A generator is a function that generates a
    // value of type T
    export interface Gen<T> {
        (): T;
    }
    export interface GenSized<T> {
        (size: number): T;
    }

    // A generator builder is a function that builds a
    // generator of type T
    export interface GenBuilder<T> {
        (...value: any): Gen<T>;
    }

    // A shrinker is a function that takes a value of type T
    // and returns a list of smaller values of type T
    export interface Shrink<T> {
        (value: T): T;
    }

    // An order is a function that takes two values of type T
    // and returns true if the first value is less than the second
    export interface Ord<T> {
        (a: T, b: T): boolean;
    }

    // A property is a function that takes a set of inputs
    // and returns true if the property holds for those inputs
    export interface Prop {
        (...value: any): boolean;
    }
}

export module Generators {
    export const genList: TypeClasses.Gen<number[]> = () => {
        let size = GenBuilders.genInt(1, 10)();
        let arr = GenBuilders.genArray(size, GenBuilders.genInt(-1000, 1000));
        return arr();
    }

    export const generateString: TypeClasses.Gen<string> = () => {
        return Math.random().toString(36).substring(7);
    }

    export const generateNumber: TypeClasses.Gen<number> = () => {
        return Math.floor(Math.random() * 1000);
    }

    export const generateBoolean: TypeClasses.Gen<boolean> = () => {
        return Math.random() > 0.5;
    }

    export const generateNull: TypeClasses.Gen<null> = () => {
        return null;
    }

    export const generateUndefined: TypeClasses.Gen<undefined> = () => {
        return undefined;
    }
}


export module GenBuilders {

    /// Generator Builders
    // These generators are used to build more complex generators
    export const oneOf: (arr: TypeClasses.Gen<any>[]) => TypeClasses.Gen<any> = (arr: TypeClasses.Gen<any>[]) => {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    export const freqOf: <T>(arr: [TypeClasses.Gen<T>, number][]) => TypeClasses.Gen<T> = <T>(arr: [TypeClasses.Gen<T>, number][]) => {
        let flatArray: TypeClasses.Gen<T>[] = [];

        for (let i = 0; i < arr.length; i++) {
            const [value, freq] = arr[i];
            for (let j = 0; j < freq; j++) {
                flatArray.push(value);
            }
        }

        return oneOf(flatArray);
    }

    // genInt(a, b) => Gen<number> for integers in the range [a, b]
    export const genInt: TypeClasses.GenBuilder<number> = (a: number, b: number) => () => {
        return Math.floor(Math.random() * (b - a + 1) + a);
    }

    // genArray(size, gen) => Gen<T[]> for arrays of size 'size' and elements generated by 'gen'
    // This is actually a generator builder, but I can't get typescript to typecheck it with GenBuilder<T[]>
    export const genArray: <T>(size: number, gen: TypeClasses.Gen<T>) => TypeClasses.Gen<T[]>
        = <T>(size: number, gen: TypeClasses.Gen<T>) => () => {
            let arr = [];
            for (let i = 0; i < size; i++) {
                arr.push(gen());
            }
            return arr;
        }
}

export module Shrinkers {
    // shrinkArray(list: T[]) => T[]
    // This is a shrinker for arrays, it removes a random element from the array
    const shrinkArray: <T>(list: T[]) => T[] = <T>(list: T[]) => {
        if (list.length === 0) {
            return [];
        }

        // Remove a random element
        let shrunk = list.slice();
        let index = Math.floor(Math.random() * list.length);
        shrunk.splice(index, 1);

        return shrunk;
    }

    // shrinkNumber(n: number) => number
    // This is a shrinker for numbers, it divides the number by 2
    const shrinkNumber: TypeClasses.Shrink<number> = (n: number) => {
        return Math.floor(n / 2);
    }

    // shrinkNumberList(list: number[]) => number[]
    export const shrinkNumberList: TypeClasses.Shrink<number[]> = (list: number[]) => {
        // Shrink the list itself
        let shrunk = shrinkArray(list);

        // Shrink Random Elements in the list
        for (let i = 0; i < shrunk.length; i++) {
            if (Math.random() > (Math.sqrt(shrunk.length) / shrunk.length)) {
                shrunk[i] = shrinkNumber(shrunk[i]);
            }
        }

        return shrunk;
    }

    export const id = <T>(x: T) => x;
}

export module KelesCheck {
    export const quickCheck: <T>(prop: TypeClasses.Prop, gen: TypeClasses.Gen<T>, shrink: TypeClasses.Shrink<T>, comp: TypeClasses.Ord<T>) 
        => null | T = <T>(prop: TypeClasses.Prop, gen: TypeClasses.Gen<T>, shrink: TypeClasses.Shrink<T>, comp: TypeClasses.Ord<T>) => {
        const numTests = 10000;
        console.log("QuickChecking...");
        const qcRes = quickCheckLoop(prop, gen, numTests);
        if (qcRes === null) {
            console.log(`QuickChecked! No bugs found in ${numTests} tests.`);
            return null;
        }

        if (shrink !== Shrinkers.id) {
            console.log("Shrinking...");
            const shResult = qcShrinkLoop(prop, shrink, qcRes, comp);
            console.log("Shrunk!");
            console.log(`Shrinked Input: ${JSON.stringify(shResult)}`);
            return shResult;
        } else {
            console.log("No Shrinking Function Provided!");
            console.log(`Buggy Input: ${JSON.stringify(qcRes)}`);
            return qcRes;
        }
    }

    export const quickCheckLoop: <T>(prop: TypeClasses.Prop, gen: TypeClasses.Gen<T>, size: number) 
        => null | T = <T>(prop: TypeClasses.Prop, gen: TypeClasses.Gen<T>, size: number) => {
        for (let i = 0; i < size; i++) {
            let value = gen();
            if (!prop(value)) {
                console.log(`QuickChecked! Bug found in ${i + 1} tests.`);
                return value;
            }
        }
        return null;

    }

    export const qcShrinkLoop: <T>(prop: TypeClasses.Prop, shrink: TypeClasses.Shrink<T>, value: T, comp: TypeClasses.Ord<T>) 
        => T = <T>(prop: TypeClasses.Prop, shrink: TypeClasses.Shrink<T>, value: T, comp: TypeClasses.Ord<T>) => {
        let shrunk: T[] = [];

        for (let i = 0; i < 4; i++) {
            // shrink the value 4 times
            shrunk.push(shrink(value));
        }

        let stillShrinkableValues: T[] = [];

        for (let i = 0; i < shrunk.length; i++) {
            // check if the 4 shrunk values are still shrinkable
            if (!prop(shrunk[i])) {
                stillShrinkableValues.push(shrunk[i]);
            }
        }

        if (stillShrinkableValues.length === 0) {
            // no more shrinkable values
            return value;
        }

        // shrink the smallest of the shrinkable values
        let smallestShrunkValue = qcShrinkLoop(prop, shrink, stillShrinkableValues[0], comp)

        for (let i = 1; i < stillShrinkableValues.length; i++) {
            let shValue = qcShrinkLoop(prop, shrink, stillShrinkableValues[i], comp);
            if (comp(shValue, smallestShrunkValue)) {
                smallestShrunkValue = shValue;
            }
        }

        return smallestShrunkValue;
    }
}