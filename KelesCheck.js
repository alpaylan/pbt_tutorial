"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KelesCheck = exports.Shrinkers = exports.GenBuilders = exports.Generators = void 0;
var Generators;
(function (Generators) {
    Generators.genList = function () {
        var size = GenBuilders.genInt(1, 10)();
        var arr = GenBuilders.genArray(size, GenBuilders.genInt(-1000, 1000));
        return arr();
    };
    Generators.generateString = function () {
        return Math.random().toString(36).substring(7);
    };
    Generators.generateNumber = function () {
        return Math.floor(Math.random() * 1000);
    };
    Generators.generateBoolean = function () {
        return Math.random() > 0.5;
    };
    Generators.generateNull = function () {
        return null;
    };
    Generators.generateUndefined = function () {
        return undefined;
    };
})(Generators = exports.Generators || (exports.Generators = {}));
var GenBuilders;
(function (GenBuilders) {
    /// Generator Builders
    // These generators are used to build more complex generators
    GenBuilders.oneOf = function (arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    };
    GenBuilders.freqOf = function (arr) {
        var flatArray = [];
        for (var i = 0; i < arr.length; i++) {
            var _a = arr[i], value = _a[0], freq = _a[1];
            for (var j = 0; j < freq; j++) {
                flatArray.push(value);
            }
        }
        return GenBuilders.oneOf(flatArray);
    };
    // genInt(a, b) => Gen<number> for integers in the range [a, b]
    GenBuilders.genInt = function (a, b) { return function () {
        return Math.floor(Math.random() * (b - a + 1) + a);
    }; };
    // genArray(size, gen) => Gen<T[]> for arrays of size 'size' and elements generated by 'gen'
    // This is actually a generator builder, but I can't get typescript to typecheck it with GenBuilder<T[]>
    GenBuilders.genArray = function (size, gen) { return function () {
        var arr = [];
        for (var i = 0; i < size; i++) {
            arr.push(gen());
        }
        return arr;
    }; };
})(GenBuilders = exports.GenBuilders || (exports.GenBuilders = {}));
var Shrinkers;
(function (Shrinkers) {
    // shrinkArray(list: T[]) => T[]
    // This is a shrinker for arrays, it removes a random element from the array
    var shrinkArray = function (list) {
        if (list.length === 0) {
            return [];
        }
        // Remove a random element
        var shrunk = list.slice();
        var index = Math.floor(Math.random() * list.length);
        shrunk.splice(index, 1);
        return shrunk;
    };
    // shrinkNumber(n: number) => number
    // This is a shrinker for numbers, it divides the number by 2
    var shrinkNumber = function (n) {
        return Math.floor(n / 2);
    };
    // shrinkNumberList(list: number[]) => number[]
    Shrinkers.shrinkNumberList = function (list) {
        // Shrink the list itself
        var shrunk = shrinkArray(list);
        // Shrink Random Elements in the list
        for (var i = 0; i < shrunk.length; i++) {
            if (Math.random() > (Math.sqrt(shrunk.length) / shrunk.length)) {
                shrunk[i] = shrinkNumber(shrunk[i]);
            }
        }
        return shrunk;
    };
    Shrinkers.id = function (x) { return x; };
})(Shrinkers = exports.Shrinkers || (exports.Shrinkers = {}));
var KelesCheck;
(function (KelesCheck) {
    KelesCheck.quickCheck = function (prop, gen, shrink, comp) {
        var numTests = 10000;
        console.log("QuickChecking...");
        var qcRes = KelesCheck.quickCheckLoop(prop, gen, numTests);
        if (qcRes === null) {
            console.log("QuickChecked! No bugs found in ".concat(numTests, " tests."));
            return null;
        }
        if (shrink !== Shrinkers.id) {
            console.log("Shrinking...");
            var shResult = KelesCheck.qcShrinkLoop(prop, shrink, qcRes, comp);
            console.log("Shrunk!");
            console.log("Shrinked Input: ".concat(JSON.stringify(shResult)));
            return shResult;
        }
        else {
            console.log("No Shrinking Function Provided!");
            console.log("Buggy Input: ".concat(JSON.stringify(qcRes)));
            return qcRes;
        }
    };
    KelesCheck.quickCheckLoop = function (prop, gen, size) {
        for (var i = 0; i < size; i++) {
            var value = gen();
            if (!prop(value)) {
                console.log("QuickChecked! Bug found in ".concat(i + 1, " tests."));
                return value;
            }
        }
        return null;
    };
    KelesCheck.qcShrinkLoop = function (prop, shrink, value, comp) {
        var shrunk = [];
        for (var i = 0; i < 4; i++) {
            // shrink the value 4 times
            shrunk.push(shrink(value));
        }
        var stillShrinkableValues = [];
        for (var i = 0; i < shrunk.length; i++) {
            // check if the 4 shrunk values are still shrinkable
            if (!prop(shrunk[i])) {
                stillShrinkableValues.push(shrunk[i]);
            }
        }
        if (stillShrinkableValues.length === 0) {
            // no more shrinkable values
            return value;
        }
        // shrink the smallest of the shrinkable values
        var smallestShrunkValue = KelesCheck.qcShrinkLoop(prop, shrink, stillShrinkableValues[0], comp);
        for (var i = 1; i < stillShrinkableValues.length; i++) {
            var shValue = KelesCheck.qcShrinkLoop(prop, shrink, stillShrinkableValues[i], comp);
            if (comp(shValue, smallestShrunkValue)) {
                smallestShrunkValue = shValue;
            }
        }
        return smallestShrunkValue;
    };
})(KelesCheck = exports.KelesCheck || (exports.KelesCheck = {}));
